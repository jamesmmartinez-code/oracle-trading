<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîÆ ORACLE V2 - Ultimate Prediction Engine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #0a0a1a 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; padding: 30px 0; }
        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00f5ff 0%, #ff00ff 50%, #00f5ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px #00f5ff); }
            to { filter: drop-shadow(0 0 20px #ff00ff); }
        }
        header p { color: #888; font-size: 1.1em; }
        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            margin-top: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 16px;
            text-align: center;
        }
        .stat-value { font-size: 1.8em; font-weight: bold; color: #00f5ff; }
        .stat-label { color: #666; font-size: 0.85em; margin-top: 5px; }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }
        .btn {
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        .btn-primary {
            background: linear-gradient(135deg, #00f5ff 0%, #0080ff 100%);
            color: #000;
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            border: 2px solid #00f5ff;
            color: #00f5ff;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(0,245,255,0.3); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .market-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.3s;
        }
        .market-card:hover { border-color: rgba(0,245,255,0.3); }
        .market-card.high-confidence { border-color: #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.2); }
        .market-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; gap: 20px; }
        .market-question { font-size: 1.15em; font-weight: 500; flex: 1; line-height: 1.4; }
        .price-badge {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.3em;
            color: #000;
            white-space: nowrap;
        }
        .market-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            color: #888;
            font-size: 0.9em;
            margin: 15px 0;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 12px;
        }
        .meta-item { display: flex; flex-direction: column; }
        .meta-label { color: #555; font-size: 0.8em; }
        .meta-value { color: #aaa; font-weight: 500; }
        .analyze-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
        }
        .analyze-btn:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(102,126,234,0.4); }
        .analysis-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .signals-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .signals-header h3 { color: #00f5ff; font-size: 1.1em; }
        .confidence-meter {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .confidence-bar {
            width: 150px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        .signals-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }
        .signal-card {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .signal-icon { font-size: 1.5em; margin-bottom: 5px; }
        .signal-name { color: #888; font-size: 0.8em; margin-bottom: 8px; }
        .signal-vote { font-size: 1.2em; font-weight: bold; margin-bottom: 5px; }
        .signal-reason { color: #555; font-size: 0.75em; line-height: 1.3; }
        .signal-weight {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            color: #666;
            margin-top: 5px;
        }
        .bullish { color: #00ff88; }
        .bearish { color: #ff4466; }
        .neutral { color: #888; }
        .result-box {
            margin-top: 20px;
            padding: 25px;
            border-radius: 16px;
            text-align: center;
        }
        .result-trade {
            background: linear-gradient(135deg, rgba(0,255,136,0.2) 0%, rgba(0,200,100,0.1) 100%);
            border: 2px solid #00ff88;
        }
        .result-no-trade {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .result-title { font-size: 1.5em; margin-bottom: 10px; }
        .result-details { color: #aaa; font-size: 0.95em; line-height: 1.6; }
        .result-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .result-stat {
            text-align: center;
        }
        .result-stat-value { font-size: 1.4em; font-weight: bold; }
        .result-stat-label { font-size: 0.8em; color: #666; }
        .kelly-box {
            background: rgba(0,245,255,0.1);
            border: 1px solid rgba(0,245,255,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }
        .loading { text-align: center; padding: 50px; color: #888; }
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #00f5ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .error { background: rgba(255,68,102,0.2); border: 1px solid #ff4466; padding: 15px; border-radius: 12px; margin: 20px 0; }
        .hidden { display: none; }
        .scan-results {
            background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,100,50,0.05) 100%);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
        }
        .scan-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .scan-header h2 {
            color: #00ff88;
            margin: 0;
        }
        .scan-stats {
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.1em;
        }
        .opportunity-card {
            background: rgba(0,0,0,0.4);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .opp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
            flex-wrap: wrap;
        }
        .opp-question {
            font-size: 1.2em;
            font-weight: 600;
            flex: 1;
            min-width: 200px;
        }
        .opp-action {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.2em;
        }
        .opp-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 12px;
        }
        .opp-stat {
            text-align: center;
        }
        .opp-stat-value {
            font-size: 1.3em;
            font-weight: bold;
        }
        .opp-stat-label {
            font-size: 0.8em;
            color: #666;
        }
        .no-opportunities {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        .no-opportunities h3 {
            color: #ffa500;
            margin-bottom: 10px;
        }
        .scanning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .scan-progress {
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }
        .scan-progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #00f5ff 0%, #00ff88 100%);
            transition: width 0.3s;
        }
        .methodology {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
        }
        .methodology h3 { color: #00f5ff; margin-bottom: 15px; }
        .methodology-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .method-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
        }
        .method-title { color: #aaa; font-weight: 600; margin-bottom: 5px; }
        .method-desc { color: #666; font-size: 0.85em; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîÆ ORACLE V2</h1>
            <p>Ultimate AI-Powered Prediction Engine</p>
            <div class="version-badge">8-Signal Ensemble ‚Ä¢ Kelly Criterion ‚Ä¢ Z-Score Analysis</div>
        </header>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="marketCount">-</div>
                <div class="stat-label">Markets Analyzed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalVolume">-</div>
                <div class="stat-label">Total Volume</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgConfidence">-</div>
                <div class="stat-label">Avg Confidence</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="signalCount">8</div>
                <div class="stat-label">Analysis Signals</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="loadMarkets()">üîÑ Refresh Markets</button>
            <button class="btn btn-primary" onclick="runFullScan()" id="scanBtn">üéØ SCAN FOR OPPORTUNITIES</button>
            <button class="btn btn-secondary" onclick="toggleView()" id="toggleBtn">üëÅÔ∏è Show All Markets</button>
        </div>

        <div id="scanResults" class="scan-results hidden">
            <div class="scan-header">
                <h2>üéØ Trade Opportunities Found</h2>
                <div class="scan-stats">
                    <span id="scannedCount">0</span> scanned ‚Ä¢
                    <span id="opportunityCount" class="bullish">0</span> opportunities
                </div>
            </div>
            <div id="opportunities"></div>
        </div>

        <div class="methodology">
            <h3>üìä Analysis Methodology</h3>
            <div class="methodology-grid">
                <div class="method-item">
                    <div class="method-title">üéØ 8-Signal Ensemble</div>
                    <div class="method-desc">Price Momentum, Mean Reversion, Volume Trend, Liquidity, Spread, Market Efficiency, Statistical Edge, Sentiment</div>
                </div>
                <div class="method-item">
                    <div class="method-title">üìà Kelly Criterion</div>
                    <div class="method-desc">Optimal bet sizing based on edge and probability to maximize long-term growth</div>
                </div>
                <div class="method-item">
                    <div class="method-title">üî¨ Z-Score Analysis</div>
                    <div class="method-desc">Statistical anomaly detection for price deviations from expected values</div>
                </div>
                <div class="method-item">
                    <div class="method-title">‚öñÔ∏è Weighted Voting</div>
                    <div class="method-desc">Signals weighted by reliability. Requires 70%+ confidence & 15%+ edge to trade</div>
                </div>
            </div>
        </div>

        <div id="error" class="error hidden"></div>
        <div id="loading" class="loading hidden">
            <div class="loading-spinner"></div>
            <p style="margin-top: 15px;">Loading markets...</p>
        </div>
        <div id="markets"></div>
    </div>

    <script>
        const CORS_PROXY = 'https://corsproxy.io/?';
        const GAMMA_API = 'https://gamma-api.polymarket.com';
        let marketsData = [];

        // ============== CONFIGURATION ==============
        const CONFIG = {
            MIN_VOLUME: 50000,          // Minimum $50k volume
            MIN_CONFIDENCE: 0.70,        // 70% confidence required
            MIN_EDGE: 0.15,              // 15% edge required
            MIN_SIGNALS_AGREE: 5,        // 5 of 8 signals must agree
            MAX_KELLY_FRACTION: 0.25,    // Never bet more than 25% of bankroll
        };

        // Signal weights (sum to 1.0)
        const SIGNAL_WEIGHTS = {
            priceMomentum: 0.15,
            meanReversion: 0.12,
            volumeTrend: 0.15,
            liquidity: 0.10,
            spreadAnalysis: 0.12,
            marketEfficiency: 0.12,
            statisticalEdge: 0.14,
            sentiment: 0.10
        };

        // ============== MAIN FUNCTIONS ==============
        async function loadMarkets() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const marketsDiv = document.getElementById('markets');

            loading.classList.remove('hidden');
            error.classList.add('hidden');
            marketsDiv.innerHTML = '';

            try {
                const response = await fetch(`${CORS_PROXY}${encodeURIComponent(GAMMA_API + '/markets?active=true&closed=false&enableOrderBook=true&limit=50')}`);
                let markets = await response.json();

                // Handle different API response formats
                if (!Array.isArray(markets)) {
                    // Try common wrapper properties
                    markets = markets.data || markets.markets || markets.results || [];
                    if (!Array.isArray(markets)) {
                        console.error('Unexpected API response format:', markets);
                        throw new Error('API returned unexpected format. Please try again.');
                    }
                }

                marketsData = markets
                    .filter(m => {
                        const vol = parseFloat(m.volume || 0);
                        const prices = typeof m.outcomePrices === 'string' ? JSON.parse(m.outcomePrices) : m.outcomePrices;
                        return vol >= CONFIG.MIN_VOLUME && prices && prices.length === 2;
                    })
                    .map(m => {
                        const prices = typeof m.outcomePrices === 'string' ? JSON.parse(m.outcomePrices) : m.outcomePrices;
                        return {
                            id: m.id,
                            question: m.question,
                            description: m.description || '',
                            volume: parseFloat(m.volume || 0),
                            volume24hr: parseFloat(m.volume24hr || 0),
                            volume1wk: parseFloat(m.volume1wk || 0),
                            volume1mo: parseFloat(m.volume1mo || 0),
                            liquidity: parseFloat(m.liquidity || m.liquidityNum || 0),
                            spread: parseFloat(m.spread || 0),
                            bestBid: parseFloat(m.bestBid || 0),
                            bestAsk: parseFloat(m.bestAsk || 0),
                            yesPrice: parseFloat(prices[0]),
                            noPrice: parseFloat(prices[1]),
                            oneDayChange: parseFloat(m.oneDayPriceChange || 0),
                            oneWeekChange: parseFloat(m.oneWeekPriceChange || 0),
                            oneMonthChange: parseFloat(m.oneMonthPriceChange || 0),
                            lastTradePrice: parseFloat(m.lastTradePrice || prices[0]),
                            endDate: m.endDate
                        };
                    })
                    .sort((a, b) => b.volume - a.volume);

                document.getElementById('marketCount').textContent = marketsData.length;
                document.getElementById('totalVolume').textContent = '$' + (marketsData.reduce((a, b) => a + b.volume, 0) / 1000000).toFixed(1) + 'M';

                renderMarkets();
            } catch (e) {
                error.textContent = 'Failed to load markets: ' + e.message;
                error.classList.remove('hidden');
            } finally {
                loading.classList.add('hidden');
            }
        }

        function renderMarkets() {
            const marketsDiv = document.getElementById('markets');
            marketsDiv.innerHTML = marketsData.slice(0, 25).map((m, i) => `
                <div class="market-card" id="market-${i}">
                    <div class="market-header">
                        <div class="market-question">${m.question}</div>
                        <div class="price-badge">${(m.yesPrice * 100).toFixed(1)}% YES</div>
                    </div>
                    <div class="market-meta">
                        <div class="meta-item">
                            <span class="meta-label">Volume</span>
                            <span class="meta-value">$${formatNumber(m.volume)}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">24h Vol</span>
                            <span class="meta-value">$${formatNumber(m.volume24hr)}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Liquidity</span>
                            <span class="meta-value">$${formatNumber(m.liquidity)}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Spread</span>
                            <span class="meta-value">${(m.spread * 100).toFixed(1)}%</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">24h Change</span>
                            <span class="meta-value ${m.oneDayChange >= 0 ? 'bullish' : 'bearish'}">${(m.oneDayChange * 100).toFixed(1)}%</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">7d Change</span>
                            <span class="meta-value ${m.oneWeekChange >= 0 ? 'bullish' : 'bearish'}">${(m.oneWeekChange * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                    <button class="analyze-btn" onclick="analyzeMarket(${i})">üî¨ Run Deep Analysis</button>
                    <div id="analysis-${i}" class="hidden"></div>
                </div>
            `).join('');
        }

        function formatNumber(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(0) + 'k';
            return n.toFixed(0);
        }

        async function analyzeAll() {
            for (let i = 0; i < Math.min(marketsData.length, 10); i++) {
                await analyzeMarket(i);
                await new Promise(r => setTimeout(r, 300));
            }
        }

        // ============== CORE ANALYSIS ENGINE ==============
        async function analyzeMarket(index) {
            const m = marketsData[index];
            const analysisDiv = document.getElementById(`analysis-${index}`);
            analysisDiv.innerHTML = '<div class="loading"><div class="loading-spinner"></div><p style="margin-top:10px">Running 8-signal analysis...</p></div>';
            analysisDiv.classList.remove('hidden');

            await new Promise(r => setTimeout(r, 800));

            // Run all 8 signals
            const signals = [
                analyzePriceMomentum(m),
                analyzeMeanReversion(m),
                analyzeVolumeTrend(m),
                analyzeLiquidity(m),
                analyzeSpread(m),
                analyzeMarketEfficiency(m),
                analyzeStatisticalEdge(m),
                analyzeSentiment(m)
            ];

            // Calculate weighted votes
            let yesWeight = 0, noWeight = 0, neutralWeight = 0;
            let yesCount = 0, noCount = 0;

            signals.forEach(s => {
                if (s.direction === 'YES') {
                    yesWeight += s.weight;
                    yesCount++;
                } else if (s.direction === 'NO') {
                    noWeight += s.weight;
                    noCount++;
                } else {
                    neutralWeight += s.weight;
                }
            });

            // Calculate confidence and edge
            const totalDirectionalWeight = yesWeight + noWeight;
            const dominantDirection = yesWeight > noWeight ? 'YES' : 'NO';
            const dominantWeight = Math.max(yesWeight, noWeight);
            const confidence = totalDirectionalWeight > 0 ? dominantWeight / (yesWeight + noWeight + neutralWeight) : 0;

            // Calculate estimated true probability
            const marketProb = dominantDirection === 'YES' ? m.yesPrice : m.noPrice;
            const estimatedTrueProb = calculateTrueProbability(m, signals, dominantDirection);
            const edge = estimatedTrueProb - marketProb;

            // Kelly Criterion calculation
            const kelly = calculateKelly(estimatedTrueProb, marketProb);
            const adjustedKelly = Math.min(kelly, CONFIG.MAX_KELLY_FRACTION);

            // Z-score for the edge
            const zScore = calculateZScore(edge, m);

            // Decision
            const signalsAgree = dominantDirection === 'YES' ? yesCount : noCount;
            const shouldTrade = confidence >= CONFIG.MIN_CONFIDENCE &&
                               edge >= CONFIG.MIN_EDGE &&
                               signalsAgree >= CONFIG.MIN_SIGNALS_AGREE &&
                               zScore >= 1.5;  // Statistically significant

            // Update card styling
            const card = document.getElementById(`market-${index}`);
            if (shouldTrade) {
                card.classList.add('high-confidence');
            } else {
                card.classList.remove('high-confidence');
            }

            // Render results
            const confColor = confidence >= 0.8 ? '#00ff88' : confidence >= 0.6 ? '#ffa500' : '#ff4466';

            analysisDiv.innerHTML = `
                <div class="analysis-section">
                    <div class="signals-header">
                        <h3>üìä 8-Signal Analysis</h3>
                        <div class="confidence-meter">
                            <span style="color: ${confColor}">${(confidence * 100).toFixed(0)}% Confidence</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: ${confidence * 100}%; background: ${confColor};"></div>
                            </div>
                        </div>
                    </div>
                    <div class="signals-grid">
                        ${signals.map(s => `
                            <div class="signal-card">
                                <div class="signal-icon">${s.icon}</div>
                                <div class="signal-name">${s.name}</div>
                                <div class="signal-vote ${s.direction === 'YES' ? 'bullish' : s.direction === 'NO' ? 'bearish' : 'neutral'}">
                                    ${s.direction === 'YES' ? 'üü¢' : s.direction === 'NO' ? 'üî¥' : '‚ö™'} ${s.direction}
                                </div>
                                <div class="signal-reason">${s.reason}</div>
                                <div class="signal-weight">Weight: ${(s.weight * 100).toFixed(0)}%</div>
                            </div>
                        `).join('')}
                    </div>

                    <div class="result-box ${shouldTrade ? 'result-trade' : 'result-no-trade'}">
                        <div class="result-title">
                            ${shouldTrade
                                ? `üéØ STRONG SIGNAL: Buy <span class="${dominantDirection === 'YES' ? 'bullish' : 'bearish'}">${dominantDirection}</span>`
                                : '‚è∏Ô∏è NO TRADE - Insufficient Edge or Confidence'}
                        </div>
                        <div class="result-details">
                            ${shouldTrade
                                ? `${signalsAgree}/8 signals agree ‚Ä¢ ${(edge * 100).toFixed(1)}% edge detected ‚Ä¢ Z-score: ${zScore.toFixed(2)}`
                                : `${signalsAgree}/8 signals agree (need ${CONFIG.MIN_SIGNALS_AGREE}) ‚Ä¢ ${(edge * 100).toFixed(1)}% edge (need ${CONFIG.MIN_EDGE * 100}%) ‚Ä¢ ${(confidence * 100).toFixed(0)}% confidence (need ${CONFIG.MIN_CONFIDENCE * 100}%)`}
                        </div>
                        <div class="result-stats">
                            <div class="result-stat">
                                <div class="result-stat-value" style="color: ${confColor}">${(confidence * 100).toFixed(0)}%</div>
                                <div class="result-stat-label">Confidence</div>
                            </div>
                            <div class="result-stat">
                                <div class="result-stat-value ${edge >= 0.15 ? 'bullish' : 'neutral'}">${(edge * 100).toFixed(1)}%</div>
                                <div class="result-stat-label">Edge</div>
                            </div>
                            <div class="result-stat">
                                <div class="result-stat-value">${zScore.toFixed(2)}</div>
                                <div class="result-stat-label">Z-Score</div>
                            </div>
                            <div class="result-stat">
                                <div class="result-stat-value">${(estimatedTrueProb * 100).toFixed(1)}%</div>
                                <div class="result-stat-label">Est. True Prob</div>
                            </div>
                        </div>
                        ${shouldTrade ? `
                            <div class="kelly-box">
                                <strong>üìê Kelly Criterion Bet Size:</strong> ${(adjustedKelly * 100).toFixed(1)}% of bankroll<br>
                                <small style="color: #888;">Based on ${(estimatedTrueProb * 100).toFixed(1)}% true probability vs ${(marketProb * 100).toFixed(1)}% market price</small>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;

            // Update average confidence
            updateAverageConfidence();
        }

        // ============== 8 ANALYSIS SIGNALS ==============

        // Signal 1: Price Momentum (short-term trend)
        function analyzePriceMomentum(m) {
            const dayChange = m.oneDayChange;
            const weekChange = m.oneWeekChange;

            // Strong momentum in one direction
            if (dayChange > 0.05 && weekChange > 0.08) {
                return {
                    name: 'Price Momentum',
                    icon: 'üìà',
                    direction: 'YES',
                    reason: `Strong upward momentum (+${(dayChange*100).toFixed(1)}% 1d, +${(weekChange*100).toFixed(1)}% 1w)`,
                    weight: SIGNAL_WEIGHTS.priceMomentum
                };
            }
            if (dayChange < -0.05 && weekChange < -0.08) {
                return {
                    name: 'Price Momentum',
                    icon: 'üìà',
                    direction: 'NO',
                    reason: `Strong downward momentum (${(dayChange*100).toFixed(1)}% 1d, ${(weekChange*100).toFixed(1)}% 1w)`,
                    weight: SIGNAL_WEIGHTS.priceMomentum
                };
            }
            return {
                name: 'Price Momentum',
                icon: 'üìà',
                direction: 'NEUTRAL',
                reason: 'No clear momentum trend',
                weight: SIGNAL_WEIGHTS.priceMomentum
            };
        }

        // Signal 2: Mean Reversion (contrarian at extremes)
        function analyzeMeanReversion(m) {
            const price = m.yesPrice;

            // Only trigger at VERY extreme prices with volume confirmation
            if (price > 0.92 && m.volume24hr < m.volume1wk / 7) {
                return {
                    name: 'Mean Reversion',
                    icon: 'üîÑ',
                    direction: 'NO',
                    reason: `Extreme high (${(price*100).toFixed(0)}%) with declining volume - overextended`,
                    weight: SIGNAL_WEIGHTS.meanReversion
                };
            }
            if (price < 0.08 && m.volume24hr > m.volume1wk / 3) {
                return {
                    name: 'Mean Reversion',
                    icon: 'üîÑ',
                    direction: 'YES',
                    reason: `Extreme low (${(price*100).toFixed(0)}%) with rising volume - potential reversal`,
                    weight: SIGNAL_WEIGHTS.meanReversion
                };
            }
            // Don't trigger mean reversion for normal extreme prices
            return {
                name: 'Mean Reversion',
                icon: 'üîÑ',
                direction: 'NEUTRAL',
                reason: 'No mean reversion signal',
                weight: SIGNAL_WEIGHTS.meanReversion
            };
        }

        // Signal 3: Volume Trend Analysis
        function analyzeVolumeTrend(m) {
            const vol24h = m.volume24hr;
            const avgDailyVol = m.volume1wk / 7;
            const volRatio = vol24h / avgDailyVol;

            // High volume spike often precedes moves
            if (volRatio > 2.5) {
                // Direction based on price change
                if (m.oneDayChange > 0) {
                    return {
                        name: 'Volume Trend',
                        icon: 'üìä',
                        direction: 'YES',
                        reason: `Volume spike ${volRatio.toFixed(1)}x avg with positive price action`,
                        weight: SIGNAL_WEIGHTS.volumeTrend
                    };
                } else if (m.oneDayChange < 0) {
                    return {
                        name: 'Volume Trend',
                        icon: 'üìä',
                        direction: 'NO',
                        reason: `Volume spike ${volRatio.toFixed(1)}x avg with negative price action`,
                        weight: SIGNAL_WEIGHTS.volumeTrend
                    };
                }
            }

            if (volRatio < 0.3 && m.volume > 100000) {
                return {
                    name: 'Volume Trend',
                    icon: 'üìä',
                    direction: 'NEUTRAL',
                    reason: 'Low volume - reduced conviction',
                    weight: SIGNAL_WEIGHTS.volumeTrend * 0.5
                };
            }

            return {
                name: 'Volume Trend',
                icon: 'üìä',
                direction: 'NEUTRAL',
                reason: 'Normal volume pattern',
                weight: SIGNAL_WEIGHTS.volumeTrend
            };
        }

        // Signal 4: Liquidity Analysis
        function analyzeLiquidity(m) {
            const liqRatio = m.liquidity / m.volume;

            if (m.liquidity > 50000 && liqRatio > 0.05) {
                return {
                    name: 'Liquidity',
                    icon: 'üíß',
                    direction: 'YES',
                    reason: `High liquidity ($${formatNumber(m.liquidity)}) - smart money present`,
                    weight: SIGNAL_WEIGHTS.liquidity
                };
            }
            if (m.liquidity < 5000) {
                return {
                    name: 'Liquidity',
                    icon: 'üíß',
                    direction: 'NEUTRAL',
                    reason: 'Low liquidity - thin market, avoid',
                    weight: SIGNAL_WEIGHTS.liquidity * 0.3
                };
            }
            return {
                name: 'Liquidity',
                icon: 'üíß',
                direction: 'NEUTRAL',
                reason: 'Adequate liquidity',
                weight: SIGNAL_WEIGHTS.liquidity
            };
        }

        // Signal 5: Spread Analysis
        function analyzeSpread(m) {
            const spread = m.spread;

            if (spread < 0.02) {
                return {
                    name: 'Spread',
                    icon: '‚ÜîÔ∏è',
                    direction: 'YES',
                    reason: `Tight spread (${(spread*100).toFixed(1)}%) - efficient pricing, confident market`,
                    weight: SIGNAL_WEIGHTS.spreadAnalysis
                };
            }
            if (spread > 0.08) {
                return {
                    name: 'Spread',
                    icon: '‚ÜîÔ∏è',
                    direction: 'NEUTRAL',
                    reason: `Wide spread (${(spread*100).toFixed(1)}%) - uncertain market`,
                    weight: SIGNAL_WEIGHTS.spreadAnalysis * 0.5
                };
            }
            return {
                name: 'Spread',
                icon: '‚ÜîÔ∏è',
                direction: 'NEUTRAL',
                reason: 'Normal spread',
                weight: SIGNAL_WEIGHTS.spreadAnalysis
            };
        }

        // Signal 6: Market Efficiency Score
        function analyzeMarketEfficiency(m) {
            // Compare last trade to mid-market
            const midPrice = (m.bestBid + m.bestAsk) / 2 || m.yesPrice;
            const lastTrade = m.lastTradePrice;
            const deviation = Math.abs(lastTrade - midPrice);

            // Check if market is pricing efficiently
            if (deviation < 0.01 && m.spread < 0.03) {
                return {
                    name: 'Market Efficiency',
                    icon: '‚ö°',
                    direction: 'NEUTRAL',
                    reason: 'Highly efficient market - hard to find edge',
                    weight: SIGNAL_WEIGHTS.marketEfficiency * 0.7
                };
            }
            if (deviation > 0.03) {
                // Inefficiency detected - trade toward mid
                if (lastTrade > midPrice) {
                    return {
                        name: 'Market Efficiency',
                        icon: '‚ö°',
                        direction: 'NO',
                        reason: `Last trade above fair value - potential mean reversion`,
                        weight: SIGNAL_WEIGHTS.marketEfficiency
                    };
                } else {
                    return {
                        name: 'Market Efficiency',
                        icon: '‚ö°',
                        direction: 'YES',
                        reason: `Last trade below fair value - potential mean reversion`,
                        weight: SIGNAL_WEIGHTS.marketEfficiency
                    };
                }
            }
            return {
                name: 'Market Efficiency',
                icon: '‚ö°',
                direction: 'NEUTRAL',
                reason: 'Normal market efficiency',
                weight: SIGNAL_WEIGHTS.marketEfficiency
            };
        }

        // Signal 7: Statistical Edge Detection
        function analyzeStatisticalEdge(m) {
            const price = m.yesPrice;
            const monthChange = m.oneMonthChange;
            const weekChange = m.oneWeekChange;

            // Look for statistical anomalies
            // Sharp recent move that might overshoot
            if (Math.abs(weekChange) > 0.15) {
                const overshot = weekChange > 0.15 ? 'YES' : 'NO';
                return {
                    name: 'Statistical Edge',
                    icon: 'üìâ',
                    direction: overshot === 'YES' ? 'NO' : 'YES',
                    reason: `${(weekChange*100).toFixed(0)}% weekly move may overshoot - contrarian opportunity`,
                    weight: SIGNAL_WEIGHTS.statisticalEdge
                };
            }

            // Prices between 40-60% are hardest to predict
            if (price > 0.4 && price < 0.6) {
                return {
                    name: 'Statistical Edge',
                    icon: 'üìâ',
                    direction: 'NEUTRAL',
                    reason: 'Price in uncertain zone (40-60%) - no statistical edge',
                    weight: SIGNAL_WEIGHTS.statisticalEdge * 0.5
                };
            }

            return {
                name: 'Statistical Edge',
                icon: 'üìâ',
                direction: 'NEUTRAL',
                reason: 'No clear statistical edge',
                weight: SIGNAL_WEIGHTS.statisticalEdge
            };
        }

        // Signal 8: Sentiment Analysis (keyword-based)
        function analyzeSentiment(m) {
            const text = (m.question + ' ' + m.description).toLowerCase();

            // Context-aware sentiment
            const strongYes = ['confirmed', 'approved', 'passed', 'winning', 'announced', 'guaranteed', 'certain'];
            const strongNo = ['rejected', 'failed', 'blocked', 'cancelled', 'impossible', 'denied', 'banned'];
            const uncertainty = ['might', 'could', 'possibly', 'uncertain', 'unknown', 'unclear'];

            const yesHits = strongYes.filter(w => text.includes(w)).length;
            const noHits = strongNo.filter(w => text.includes(w)).length;
            const uncertainHits = uncertainty.filter(w => text.includes(w)).length;

            if (yesHits > noHits + 1 && uncertainHits < 2) {
                return {
                    name: 'Sentiment',
                    icon: 'üí≠',
                    direction: 'YES',
                    reason: `Strong positive indicators (${yesHits} yes keywords)`,
                    weight: SIGNAL_WEIGHTS.sentiment
                };
            }
            if (noHits > yesHits + 1 && uncertainHits < 2) {
                return {
                    name: 'Sentiment',
                    icon: 'üí≠',
                    direction: 'NO',
                    reason: `Strong negative indicators (${noHits} no keywords)`,
                    weight: SIGNAL_WEIGHTS.sentiment
                };
            }
            return {
                name: 'Sentiment',
                icon: 'üí≠',
                direction: 'NEUTRAL',
                reason: 'Mixed or neutral sentiment',
                weight: SIGNAL_WEIGHTS.sentiment
            };
        }

        // ============== STATISTICAL FUNCTIONS ==============

        function calculateTrueProbability(m, signals, direction) {
            // Base on market price, adjusted by signal consensus
            const baseProb = direction === 'YES' ? m.yesPrice : m.noPrice;

            // Calculate signal adjustment
            let adjustment = 0;
            let totalWeight = 0;

            signals.forEach(s => {
                if (s.direction === direction) {
                    adjustment += s.weight * 0.08; // Each agreeing signal adds up to 8%
                } else if (s.direction !== 'NEUTRAL') {
                    adjustment -= s.weight * 0.04; // Disagreeing signals subtract
                }
                totalWeight += s.weight;
            });

            // Bound the result
            return Math.max(0.05, Math.min(0.95, baseProb + adjustment));
        }

        function calculateKelly(trueProb, marketPrice) {
            // Kelly = (bp - q) / b
            // where b = odds, p = true prob, q = 1-p
            if (trueProb <= marketPrice) return 0;

            const b = (1 / marketPrice) - 1; // Decimal odds - 1
            const p = trueProb;
            const q = 1 - p;

            const kelly = (b * p - q) / b;
            return Math.max(0, kelly);
        }

        function calculateZScore(edge, m) {
            // Simplified Z-score based on edge and sample size (volume as proxy)
            const n = Math.sqrt(m.volume / 1000); // Sample size proxy
            const stdErr = 0.5 / Math.sqrt(n); // Standard error estimate
            return edge / stdErr;
        }

        function updateAverageConfidence() {
            const analysisBoxes = document.querySelectorAll('.result-box');
            if (analysisBoxes.length === 0) {
                document.getElementById('avgConfidence').textContent = '-';
                return;
            }
            // This would calculate average but we'll show a placeholder
            document.getElementById('avgConfidence').textContent = analysisBoxes.length + ' analyzed';
        }

        // ============== FULL SCAN MODE ==============
        let showingOpportunitiesOnly = false;
        let opportunities = [];

        async function runFullScan() {
            const scanBtn = document.getElementById('scanBtn');
            scanBtn.disabled = true;
            scanBtn.textContent = '‚è≥ Scanning...';

            // Create scanning overlay
            const overlay = document.createElement('div');
            overlay.className = 'scanning-overlay';
            overlay.id = 'scanOverlay';
            overlay.innerHTML = `
                <h2 style="color: #00f5ff; margin-bottom: 10px;">üî¨ Deep Scanning Markets</h2>
                <p style="color: #888;" id="scanStatus">Analyzing market 0 of ${marketsData.length}</p>
                <div class="scan-progress">
                    <div class="scan-progress-fill" id="scanProgress" style="width: 0%"></div>
                </div>
                <p style="color: #666; font-size: 0.9em;">Running 8-signal analysis on each market...</p>
            `;
            document.body.appendChild(overlay);

            opportunities = [];
            let analyzed = 0;

            for (let i = 0; i < marketsData.length; i++) {
                const result = await analyzeMarketSilent(i);
                analyzed++;

                document.getElementById('scanStatus').textContent = `Analyzing market ${analyzed} of ${marketsData.length}`;
                document.getElementById('scanProgress').style.width = `${(analyzed / marketsData.length) * 100}%`;

                if (result.shouldTrade) {
                    opportunities.push({
                        ...marketsData[i],
                        analysis: result
                    });
                }

                // Small delay to prevent UI freeze
                await new Promise(r => setTimeout(r, 50));
            }

            // Remove overlay
            document.getElementById('scanOverlay').remove();

            // Update stats
            document.getElementById('scannedCount').textContent = analyzed;
            document.getElementById('opportunityCount').textContent = opportunities.length;

            // Show results
            showingOpportunitiesOnly = true;
            document.getElementById('toggleBtn').textContent = 'üëÅÔ∏è Show All Markets';
            document.getElementById('scanResults').classList.remove('hidden');
            document.getElementById('markets').classList.add('hidden');
            document.querySelector('.methodology').classList.add('hidden');

            renderOpportunities();

            scanBtn.disabled = false;
            scanBtn.textContent = 'üéØ SCAN FOR OPPORTUNITIES';

            // Update average confidence
            document.getElementById('avgConfidence').textContent = `${opportunities.length} trades`;
        }

        function renderOpportunities() {
            const container = document.getElementById('opportunities');

            if (opportunities.length === 0) {
                container.innerHTML = `
                    <div class="no-opportunities">
                        <h3>‚ö†Ô∏è No Strong Opportunities Found</h3>
                        <p>All ${marketsData.length} markets were analyzed, but none met the strict criteria:</p>
                        <ul style="text-align: left; display: inline-block; margin-top: 15px; color: #666;">
                            <li>70%+ confidence required</li>
                            <li>15%+ edge required</li>
                            <li>5 of 8 signals must agree</li>
                            <li>Z-score must be ‚â• 1.5 (statistically significant)</li>
                        </ul>
                        <p style="margin-top: 20px; color: #888;">This is good! It means the system is being selective and avoiding low-quality trades.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = opportunities.map((opp, i) => `
                <div class="opportunity-card">
                    <div class="opp-header">
                        <div class="opp-question">${opp.question}</div>
                        <div class="opp-action">BUY ${opp.analysis.direction} @ ${(opp.analysis.direction === 'YES' ? opp.yesPrice * 100 : opp.noPrice * 100).toFixed(1)}%</div>
                    </div>
                    <div class="opp-stats">
                        <div class="opp-stat">
                            <div class="opp-stat-value bullish">${(opp.analysis.confidence * 100).toFixed(0)}%</div>
                            <div class="opp-stat-label">Confidence</div>
                        </div>
                        <div class="opp-stat">
                            <div class="opp-stat-value bullish">${(opp.analysis.edge * 100).toFixed(1)}%</div>
                            <div class="opp-stat-label">Edge</div>
                        </div>
                        <div class="opp-stat">
                            <div class="opp-stat-value">${opp.analysis.zScore.toFixed(2)}</div>
                            <div class="opp-stat-label">Z-Score</div>
                        </div>
                        <div class="opp-stat">
                            <div class="opp-stat-value">${opp.analysis.signalsAgree}/8</div>
                            <div class="opp-stat-label">Signals</div>
                        </div>
                        <div class="opp-stat">
                            <div class="opp-stat-value">${(opp.analysis.kelly * 100).toFixed(1)}%</div>
                            <div class="opp-stat-label">Kelly Size</div>
                        </div>
                        <div class="opp-stat">
                            <div class="opp-stat-value">$${formatNumber(opp.volume)}</div>
                            <div class="opp-stat-label">Volume</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Silent analysis (no DOM updates)
        async function analyzeMarketSilent(index) {
            const m = marketsData[index];

            const signals = [
                analyzePriceMomentum(m),
                analyzeMeanReversion(m),
                analyzeVolumeTrend(m),
                analyzeLiquidity(m),
                analyzeSpread(m),
                analyzeMarketEfficiency(m),
                analyzeStatisticalEdge(m),
                analyzeSentiment(m)
            ];

            let yesWeight = 0, noWeight = 0, neutralWeight = 0;
            let yesCount = 0, noCount = 0;

            signals.forEach(s => {
                if (s.direction === 'YES') {
                    yesWeight += s.weight;
                    yesCount++;
                } else if (s.direction === 'NO') {
                    noWeight += s.weight;
                    noCount++;
                } else {
                    neutralWeight += s.weight;
                }
            });

            const dominantDirection = yesWeight > noWeight ? 'YES' : 'NO';
            const dominantWeight = Math.max(yesWeight, noWeight);
            const confidence = dominantWeight / (yesWeight + noWeight + neutralWeight);

            const marketProb = dominantDirection === 'YES' ? m.yesPrice : m.noPrice;
            const estimatedTrueProb = calculateTrueProbability(m, signals, dominantDirection);
            const edge = estimatedTrueProb - marketProb;

            const kelly = calculateKelly(estimatedTrueProb, marketProb);
            const adjustedKelly = Math.min(kelly, CONFIG.MAX_KELLY_FRACTION);

            const zScore = calculateZScore(edge, m);

            const signalsAgree = dominantDirection === 'YES' ? yesCount : noCount;
            const shouldTrade = confidence >= CONFIG.MIN_CONFIDENCE &&
                               edge >= CONFIG.MIN_EDGE &&
                               signalsAgree >= CONFIG.MIN_SIGNALS_AGREE &&
                               zScore >= 1.5;

            return {
                shouldTrade,
                direction: dominantDirection,
                confidence,
                edge,
                zScore,
                kelly: adjustedKelly,
                signalsAgree,
                signals
            };
        }

        function toggleView() {
            const btn = document.getElementById('toggleBtn');
            const scanResults = document.getElementById('scanResults');
            const markets = document.getElementById('markets');
            const methodology = document.querySelector('.methodology');

            if (showingOpportunitiesOnly) {
                scanResults.classList.add('hidden');
                markets.classList.remove('hidden');
                methodology.classList.remove('hidden');
                btn.textContent = 'üéØ Show Opportunities Only';
                showingOpportunitiesOnly = false;
            } else {
                if (opportunities.length > 0 || document.getElementById('scannedCount').textContent !== '0') {
                    scanResults.classList.remove('hidden');
                    markets.classList.add('hidden');
                    methodology.classList.add('hidden');
                    btn.textContent = 'üëÅÔ∏è Show All Markets';
                    showingOpportunitiesOnly = true;
                } else {
                    alert('Run a scan first to find opportunities!');
                }
            }
        }

        // ============== INITIALIZATION ==============
        loadMarkets();
    </script>
</body>
</html>
